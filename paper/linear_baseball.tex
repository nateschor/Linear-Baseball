\documentclass{article}
\usepackage{setspace}
\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{url}
\usepackage{indentfirst} 
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage{makecell}
\usepackage{xcolor}

\usepackage{graphicx}
\graphicspath{ {figures/} }

\title{Constructing Optimal MLB Teams with Linear Programming}
\author{Nathan Schor}
\date{August 28, 2022}

\doublespacing
\begin{document}

\providecommand{\keywords}[1]
{
  \small	
  \textbf{\textit{Keywords---}} #1
}

\maketitle
\begin{abstract}
Major League Baseball teams face trade-offs in building talented teams without overspending. Teams need to make difficult choices about which players to roster, how many players to keep at each position, and how much to pay those players. This paper provides insights into managing these trade-offs thorough setting up a constrained optimization problem that seeks to maximize total team performance, subject to player's salary and position constraints. 
\end{abstract}
\keywords{MLB, Constrained Optimization, Roster Construction}
\newpage
\tableofcontents
\newpage
\section{Introduction}

The purpose of this research is to investigate the relationship between salary and team performance in Major League Baseball (MLB). We do this by looking at actual outcomes for MLB teams in 2021 and compare those results to optimal rosters using linear programming. Our goal is to analyze the gap between current team performance and their potential optimal performance. 

We begin with 2021 salary data for each MLB team from \cite{Brown2021}. This data is supplemented with each player's 2021 salary, team, position, and JEFFBAGWELL (our performance metric, abbreviated JB. JB stands for \textbf{J}oint \textbf{E}stimate \textbf{F}eaturing \textbf{F}anGraphs and \textbf{B}-R \textbf{A}ggregated to \textbf{G}enerate \textbf{W}ar, \textbf{E}qually \textbf{L}eveling \textbf{L}ists \cite{JB}. WAR is a metric that quantifies each player's value in terms of how many wins they provide \cite{WAR}. Next, we seek to maximize JB for each of the 30 teams subject to salary and player position constraints, and visualize the results. Lastly, we discuss the implications of the gap between teams' current roster and their optimal roster.

\section{Literature Review}

The relationship between spending and performance is common in both the public baseball discourse and in the SABR\footnote{SABR is the Society for American Baseball Research, an organization dedicated to discovering objective baseball knowledge \url{https://sabr.org/}} baseball community. The book \emph{Moneyball} \cite{Moneyball} began the baseball revolution. One example of using linear programming in baseball is \cite{McIntyre2016}. Another examples of linear programming in baseball is \cite{Adler99baseball}. An instance of linear programming in other sports is \cite{Aramouni2021}.

\section{Methodology/Data}

\subsection{Data Cleaning}

To clean the player dataset, we first assign positions to each player. A player's position is recorded as the position they played most frequently during the season (if they played two positions an equal amount of times, their position was randomly assigned to one of the two positions). Players with a \$0 salary or a missing salary are removed. A pitcher is classified as a Starting Pitcher (SP) if $\geq$ 50\% of their appearances were as a starter, and otherwise are classified as a Relief Pitcher (RP). Furthermore, First Basemen (1B), Second Basemen (2B), Third Basemen (3B), and Shortstops (SS) are classified as Infielders (IF). Left Fielders (LF), Center Fielders (CF), and Right Fielders (RF) are classified as Outfielders (OF). Catchers (C) and Designated Hitters (DH) are left as their own individual categories. 

\subsection{Salary and JEFFBAGWELL by Position}

Baseball teams need to make important decisions about which players to have on their team, and how much to pay them. An interesting aspect is that each position is not equally valuable to creating a winning team, and, consequently, players at different positions have varying salaries (controlling for skill level). 

In Figure \ref{fig:salary_position_boxplot}, we see how salary varies by position. The median salary for a Starting Pitcher is around \$5,000,000 while the median salary for a Relief Pitcher is closer to \$1,000,000. The salary distributions also vary drastically within infield and outfield positions. Starting Pitchers and Relief Pitchers also have the largest number of outliers.

\begin{figure}[H]
\caption{Boxplot of Salary (for Players with Salary $> \$0$) by Position}
\label{fig:salary_position_boxplot}
\centering
\includegraphics[width=0.7\paperwidth, scale=1.25]{salary_position_boxplots.png}
\end{figure}

It is interesting to compare this with Figure \ref{fig:war_position_boxplot}. C and RF have the lowest median values in both. However, IF and OF positions are much closer together in the JB plot. This suggests a potential discrepancy between how much players are valued and how much they are paid--if players were perfectly paid according to their value, we would expect the position ordering on the y-axis of the two graphs to be identical.  

\begin{figure}[H]
\caption{Boxplot of JEFFBAGWELL (for Players with Salary $> \$0$) by Position}
\label{fig:war_position_boxplot}
\centering
\includegraphics[width=0.7\paperwidth, scale=1.25]{war_position_boxplots.png}
\end{figure}

\subsection{Solving the Optimization Problem}

The decision variables ($x_{i}$) are which MLB players will be selected for each team \emph{T}. $x_{i}$ is a binary variable that equals 1 if player \emph{i} is chosen, and 0 if they are not. The objective function is to maximize the JB $\forall T \in {1, 2, ..., 29, 30}$:
\begin{equation}
\sum_{i = 1}^{N} x_{i} * JB_{i}
\end{equation} where \emph{N} is the total number of eligible players in 2021.

subject to the following constraints:

\begin{equation}
\sum_{i = 1}^{N} x_{i} = 25
\end{equation}
\begin{equation}
\sum_{i = 1}^{N} x_{i} = 5 \quad \forall x_i \in SP
\end{equation}
\begin{equation}
\sum_{i = 1}^{N} x_{i} = 7 \quad \forall x_i \in RP
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in CF
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in RF
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in LF
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in 2B
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in 3B
\end{equation} 
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in 1B
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} \geq 1 \quad \forall x_i \in SS
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} = 2 \quad \forall x_i \in C
\end{equation}
\begin{equation}
\sum_{i = 1}^{N} x_{i} = 1 \quad \forall x_i \in DH
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i} = 5 \quad \forall x_i \in IF
\end{equation}
\begin{equation} 
\sum_{i = 1}^{N} x_{i}  = 5 \quad \forall x_i \in OF 
\end{equation}
\begin{equation}
\sum_{i = 1}^{N} x_{i} * x_{salary} \leq T_{salary}
\end{equation}

Equation (2) constrains each team to have exactly 25 players. Equations (3) - (15) stipulate the number of players at each position and the total number of players allowed for grouped positions.   (16) requires that each team spend no more on players than they did in the actual 2021 season. 

\section{Computational Experiment and Results}

We solve the constrained optimization problem for all 30 teams to generate each team's optimal 25 player roster. In Table 1, we see there are 5 players who are chosen for each team, and 18 players who are chosen more than 20 times. In Table 2, we see that teams have at most 3 players who were on both their actual and optimal teams. The modal amount of players to have on both the optimal and actual team is 0. 

\label{tab:teams_picked}
\input{tables/teams_picked.tex}

%\begin{table}
%\caption{Number of Players who are on both the Optimal and Actual Teams}
\label{tab:optimal_and_actual}
\input{tables/num_players_actual_and_optimal.tex}
%\end{table}

In Figure \ref{fig:cowplot}, we sum the salary and JB for each of the actual 30 teams' rosters' in the graph on the left, and we sum the salary and JB for each of the 30 optimized teams' rosters' on the right. Each point represents a team.


\begin{figure}[h]
\caption{Scatterplots of a Team's Total JEFFBAGWELL vs. Total Dollars Spent for the Actual Team (Left)and Optimal Team (Right). The Red and Blue lines are constructed using LOESS.} 
\label{fig:cowplot}
\centering
\includegraphics[width=0.7\paperwidth, scale=1.25]{bwar_salary_scatter_cowplot.png}
\end{figure}


%\begin{table}
%\caption{Five rows from the \emph{Hamilton} dataset.}
%\label{tab:example}
%\input{tables/example_raw_data.tex}
%\end{table}

\section{Discussion and Conclusions}

\subsection{Actual vs. Optimal Plots}

The shape of the two graphs in Figure \ref{fig:cowplot} is interesting. The points on the left are relatively scattered, but with a general upward trend--JB and dollars spent are positively correlated. With the smoother, we see that there is a roughly linear relationship up until the salary hits \$100,000,000. JB then \emph{decreases} up until \$150,000,000, where it then continues to increase in a concave upwards fashion.

Nearly all the points on the right fall along a single curve that is almost entirely non-decreasing, and roughly linear up until around \$200,000,000. Some takeaways from examining these two curves:
\begin{singlespace}
\begin{itemize}
	\item{The marginal value of a player is non-constant}
	\item{Almost all teams that are at the bottom of the spending distribution would benefit from spending to acquire higher JB players, but additional spending is not worthwhile for teams at the top of the distribution}
	\item{Teams can use their current status (left curve) and their optimal status (right curve) to find a more favorable location that is between the two curves}
\end{itemize}
\end{singlespace}

\subsection{Actual vs. Optimal Table}

It is surprising how few players are on the same actual and optimal team in Table 2. This table gives a rough sense of bargain star power for each team. Assuming that players are paid what they are worth (which often does not happen until free agency), the high costs of having an elite player on the team might not offset the increase in JB. Teams are able to have the most desirable combination of high JB and low cost by developing or acquiring players \emph{before} they have attained star level, since they then pay a premium once the player is an established star. 

\section{Limitations}

There are a number of limitations for this work. The metric JB is an imperfect measure of player performance. Teams know \emph{ex-ante} how much they will pay a player for the season, but they do not know what the player's performance will be prior to the season. We also use data only for the 2021 season and thus only have 30 data points for teams. It is possible that the relationship between JB and salary varies by season, and that is left as an area for future work. Furthermore, we have assumed that all players are currently available on the free agent market. This assumption is clearly unrealistic since most of the players who are selected for the optimal teams are currently under contract with particular MLB teams. 

\newpage

\bibliography{references}
\bibliographystyle{apalike}

\newpage

\section{Appendix}

\subsection{Figures}

\begin{figure}[h]
\caption{Histogram of Salary for Players with Salary $> \$0$}
\label{fig:salary_hist}
\centering
\includegraphics[width=0.7\paperwidth, scale=1.25]{salary_hist.png}
\end{figure}

\newpage
\begin{figure}[h]
\caption{Histogram of JEFFBAGWELL for Players with Salary $> \$0$}
\label{fig:bwar_hist}
\centering
\includegraphics[width=0.7\paperwidth, scale=1.25]{war_hist.png}
\end{figure}

\newpage

\subsection{Code}

All of the replication files for this paper can be found at \url{https://github.com/nateschor/Linear-Baseball}

\begin{singlespace}
\begin{verbatim}

00_ingest_data.R

pacman::p_load(
  tidyverse,
  fst
)

df_raw <- read_csv("https://raw.githubusercontent.com/NeilPaine538/MLB-WAR-data-historical/master/jeffbagwell_war_historical.csv") %>% 
  glimpse()

write_fst(df_raw, "data/raw/all_data.fst")

df_payroll <- data.frame(
  stringsAsFactors = FALSE,
       check.names = FALSE,
              Club = c("Dodgers","Yankees","Mets",
                       "Phillies","Astros","R. Sox","Padres","Angels",
                       "Cardinals","Nationals","Giants","B. Jays","Cubs","Braves",
                       "W. Sox","Reds","Twins","Rockies","Brewers",
                       "Rangers","D-Backs","Royals","Mariners","A's","Tigers",
                       "Rays","Marlins","Orioles","Guardians","Pirates"),
            `2021` = c("$262,108,948","$203,628,978",
                       "$198,818,899","$192,366,818","$189,586,134",
                       "$187,356,913","$184,125,634","$182,925,936","$168,923,070",
                       "$168,252,361","$165,869,140","$152,261,601",
                       "$152,189,618","$148,497,447","$141,908,402","$131,309,602",
                       "$125,983,176","$119,908,394","$105,991,594",
                       "$104,310,488","$99,951,436","$94,475,853","$93,650,276",
                       "$90,402,244","$86,047,409","$76,856,333","$60,877,424",
                       "$59,054,021","$53,010,498","$50,337,389"),
            `2019` = c("$205,147,830","$225,978,235",
                       "$146,217,185","$160,974,755","$169,831,987",
                       "$228,403,210","$104,000,709","$165,595,376","$178,872,485",
                       "$205,283,436","$182,810,115","$120,288,261",
                       "$220,307,173","$136,147,636","$97,304,607","$135,364,998",
                       "$125,205,980","$151,889,647","$132,645,682",
                       "$135,307,635","$109,903,547","$101,984,743","$139,064,933",
                       "$95,733,594","$117,097,633","$67,443,534","$75,671,476",
                       "$82,784,110","$123,127,347","$78,286,587"),
            Change = c("$56,961,118","($22,349,257)",
                       "$52,601,714","$31,392,063","$19,754,147",
                       "($41,046,297)","$80,124,925","$17,330,560","($9,949,415)",
                       "($37,031,075)","($16,940,975)","$31,973,340",
                       "($68,117,555)","$12,349,811","$44,603,795","($4,055,396)",
                       "$777,196","($31,981,253)","($26,654,088)","($30,997,147)",
                       "($9,952,111)","($7,508,890)","($45,414,657)",
                       "($5,331,350)","($31,050,224)","$9,412,799","($14,794,052)",
                       "($23,730,089)","($70,116,849)","($27,949,198)"),
         `%.(+/-)` = c("28%","-10%","36%","20%",
                       "12%","-18%","77%","10%","-6%","-18%","-9%","27%",
                       "-31%","9%","46%","-3%","1%","-21%","-20%","-23%",
                       "-9%","-7%","-33%","-6%","-27%","14%","-20%",
                       "-29%","-57%","-36%")
) %>% 
  select(Team = Club, Payroll = `2021`) %>% 
  mutate(
    Payroll = str_sub(Payroll, 2, -1),
    Payroll = str_remove_all(Payroll, ","),
    Payroll = as.double(Payroll)
  )

write_csv(df_payroll, "data/derived/payroll_2021.csv")

01_prepare_player_data.R

pacman::p_load(
  tidyverse,
  fst
)

df_2021 <- read_fst("data/raw/all_data.fst") %>% 
  filter(year_ID == 2021) %>% 
  glimpse()

# Salary ------------------------------------------------------------------

df_salary <- df_2021 %>% 
  group_by(player_name) %>% 
  summarize(
    salary = sum(salary, na.rm = TRUE),
    bwar = sum(bwar162, na.rm = TRUE),
    pwar = sum(pwar162, na.rm = TRUE)
  ) %>% 
  filter(
    if_all(c(salary, bwar, pwar), ~ !is.na(.))
  ) %>% 
  print()

# Position ---------------------------------------------------------------

df_pitcher_position <- df_2021 %>% 
  select(player_name, starts, g_pitch) %>% 
  filter(
    if_all(c(starts, g_pitch), ~ !is.na(.))
  ) %>%
  group_by(player_name) %>% 
  summarize(
    across(everything(), ~ sum(.))
  ) %>% 
  transmute(
    player_name,
    position = if_else(starts / g_pitch >= .5, "SP", "RP")
  ) %>% 
  filter(player_name != "Shohei Ohtani") %>% 
  print()

df_fielder_position <- df_2021 %>% 
  select(player_name, starts_with("gms")) %>% 
  group_by(player_name) %>% 
  summarize(
    across(everything(), ~ sum(.))
  ) %>% 
  ungroup() %>% 
  pivot_longer(., -player_name, 
               names_to = "position", 
               values_to = "games_played", 
               names_prefix = "gms_") %>%
  filter(position != "OF") %>% 
  group_by(player_name) %>% 
  slice_max(games_played, with_ties = FALSE, n = 1) %>% 
  ungroup() %>%
  filter(position %in% c("C", "1B", "2B", "3B", "SS", "CF", "LF", "RF", "DH")) %>%
  select(player_name, position) %>% 
  anti_join(df_pitcher_position, by = "player_name") %>% 
  print()

df_position <- bind_rows(df_fielder_position, df_pitcher_position)

check_unique_players <- df_position %>% 
  count(player_name) %>% 
  slice_max(n, with_ties = FALSE) %>% 
  pull(n)

stopifnot("Each player should only occur once in dataset" = check_unique_players == 1)

# Team --------------------------------------------------------------------

df_team <- df_2021 %>% 
  select(player_name, team_ID, stint_ID, starts_with("gms")) %>% 
  pivot_longer(., starts_with("gms"), 
               names_to = "position", values_to = "games", names_prefix = "gms_") %>% 
  select(-position) %>% 
  group_by(player_name, team_ID, stint_ID) %>% 
  summarize(
    games = sum(games)
  ) %>% 
  group_by(player_name) %>% 
  slice_max(games, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(player_name, team = team_ID)


# Merged Dataset ----------------------------------------------------------

df <- list(df_salary, df_position, df_team) %>% 
  reduce(full_join, by = "player_name") %>% 
  filter(
    if_all(everything(), ~ !is.na(.))
  ) %>% 
  mutate(
    grouped_position = case_when(
      position %in% c("1B", "2B", "SS", "3B") ~ "IF",
      position %in% c("LF", "CF", "RF") ~ "OF",
      TRUE ~ position
    ),
    position = if_else(player_name == "Anthony Rizzo", "1B", position),
    grouped_position = if_else(player_name == "Anthony Rizzo", "IF", grouped_position)
  ) %>% 
  filter(salary > 0) %>%  
  pivot_longer(., c(bwar, pwar), names_to = "war_type", values_to = "war_value") %>% 
  filter((grouped_position %in% c("SP", "RP") & war_type == "pwar") |
           (! grouped_position %in% c("SP", "RP") & war_type == "bwar")) %>%
  select(-war_type) %>% 
  print()

write_csv(df, "data/derived/merged_players.csv")
 
02_solve_linear_program.R


pacman::p_load(
  tidyverse,
  lpSolve
)

df_players <- read_csv("data/derived/merged_players.csv") 

df_payroll <- read_csv("data/derived/payroll_2021.csv")

num_players <- nrow(df_players)

Create_Individual_Position_Indicator <- function(pos) {
  
  if_else(df_players %>% pull(position) == pos, 1, 0)
}

Create_Grouped_Position_Indicator <- function(pos) {
  
  if_else(df_players %>% pull(grouped_position) == pos, 1, 0)
}


Solve_Team_LP <- function(team) {
  
  team_salary <- df_payroll %>% 
    filter(Team == team) %>% 
    pull(Payroll)
  
  constraints <- rbind(
    rep(1, num_players),
    Create_Individual_Position_Indicator("SP"),
    Create_Individual_Position_Indicator("RP"),
    Create_Individual_Position_Indicator("CF"),
    Create_Individual_Position_Indicator("RF"),
    Create_Individual_Position_Indicator("LF"),
    Create_Individual_Position_Indicator("2B"),
    Create_Individual_Position_Indicator("3B"),
    Create_Individual_Position_Indicator("1B"),
    Create_Individual_Position_Indicator("SS"),
    Create_Individual_Position_Indicator("C"),
    Create_Individual_Position_Indicator("DH"),
    Create_Grouped_Position_Indicator("IF"),
    Create_Grouped_Position_Indicator("OF"),
    df_players$salary
    
  )
  
    objective <- df_players$war_value
    signs <- c(
      rep("==", 3),
      rep(">=", 7),
      rep("==", 4),
      "<="
    )
  
  constraint_rhs <- c(25, 
                      5,
                      7,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      2,
                      1,
                      5,
                      5,
                      team_salary)
  
  model <- lp("max", objective, constraints, signs, constraint_rhs, 
              all.bin = TRUE,
              compute.sens = 1)
  
  solution <- model$solution
  
  df_solution <- df_players %>% 
    slice(which(solution == 1)) %>% 
    arrange(desc(war_value))
  
  return(df_solution)
}

df_payroll <- df_payroll %>% 
  mutate(
    team_id = row_number() %>% as.character()
  )

df_lp_solved <- map_dfr(df_payroll$Team, ~ Solve_Team_LP(.), .id = "team_id") %>% 
  left_join(., df_payroll, by = "team_id") %>% 
  select(-team_id) %>% 
  mutate(
    optimal_team = case_when(
      Team == "A's" ~ "OAK", 
      Team == "Angels" ~ "LAA", 
      Team == "Astros" ~ "HOU", 
      Team == "B. Jays" ~ "TOR", 
      Team == "Braves" ~ "ATL", 
      Team == "Brewers" ~ "MIL", 
      Team == "Cardinals" ~ "STL", 
      Team == "Cubs" ~ "CHC", 
      Team == "D-Backs" ~ "ARI", 
      Team == "Dodgers" ~ "LAD", 
      Team == "Giants" ~ "SFG", 
      Team == "Guardians" ~ "CLE", 
      Team == "Mariners" ~ "SEA", 
      Team == "Marlins" ~ "MIA", 
      Team == "Mets" ~ "NYM", 
      Team == "Nationals" ~ "WSN", 
      Team == "Orioles" ~ "BAL", 
      Team == "Padres" ~ "SDP", 
      Team == "Phillies" ~ "PHI", 
      Team == "Pirates" ~ "PIT", 
      Team == "R. Sox" ~ "BOS", 
      Team == "Rangers" ~ "TEX", 
      Team == "Rays" ~ "TBR", 
      Team == "Reds" ~ "CIN", 
      Team == "Rockies" ~ "COL", 
      Team == "Royals" ~ "KCR", 
      Team == "Tigers" ~ "DET", 
      Team == "Twins" ~ "MIN", 
      Team == "W. Sox" ~ "CHW", 
      Team == "Yankees" ~ "NYY"
    )
) %>% 
  rename(actual_team = team) %>% 
  select(-Team) %>% 
  print()

write_csv(df_lp_solved, "data/derived/lp_solved.csv")

03_create_figures_and_tables.R


pacman::p_load(
  tidyverse,
  cowplot,
  kableExtra
)

# Data --------------------------------------------------------------------

df_players <- read_csv("data/derived/merged_players.csv") %>% 
  filter(salary > 0) %>% 
  print()

df_lp <- read_csv("data/derived/lp_solved.csv") %>% 
  print()

# Plots -------------------------------------------------------------------

p_salary_hist <- ggplot(df_players, aes(x = salary)) +
  geom_histogram(fill = "blue", color = "black", bins = 50) +
  scale_x_continuous(label = scales::dollar, name = "Salary") +
  scale_y_continuous(expand = expansion(0, 0), name = "Count") +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank()
  )

p_war <- ggplot(df_players, aes(x = war_value)) +
  geom_histogram(fill = "blue", color = "black", bins = 30) +
  scale_x_continuous(name = "JEFFBAGWELL") +
  scale_y_continuous(expand = expansion(0, 0), name = "Count") +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank()
  )

Reorder_By_Median <- function(salary_or_war) {
  
  df_players %>% 
    group_by(position) %>% 
    summarize(
      metric_median = median({{salary_or_war}})
    ) %>% 
    arrange(metric_median) %>% 
    pull(position) %>% 
    as_factor(., )
}

factor_salary <- Reorder_By_Median(salary) 
factor_war <- Reorder_By_Median(war_value)

p_salary_position <- ggplot(df_players, aes(x = salary, y = factor(position, levels = factor_salary))) +
  geom_boxplot(fill = "red") +
  scale_x_continuous(label = scales::dollar, name = "Salary") +
  scale_y_discrete(expand = expansion(0, 0), name = "Position") +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank()
  ) 

p_war_position <- ggplot(df_players, aes(x = war_value, y = factor(position, levels = factor_war))) +
  geom_boxplot(fill = "red") +
  scale_x_continuous(name = "JEFFBAGWELL") +
  scale_y_discrete(expand = expansion(0, 0), name = "Position") +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank()
  ) 

df_actual_salary_war <- df_players %>% 
  group_by(team) %>% 
  summarize(
    total_salary = sum(salary),
    total_war = sum(war_value)
  )

df_optimal_salary_war <- df_lp %>% 
  group_by(optimal_team) %>% 
  summarize(
    total_salary = sum(salary),
    total_war = sum(war_value)
  )

Plot_WAR_VS_SALARY <- function(actual_or_optimal) {
  
  line_color <- switch (actual_or_optimal,
    "actual" = "blue",
    "optimal" = "red"
  )
  
  plotting_data <- switch (actual_or_optimal,
    "actual" = df_actual_salary_war,
    "optimal" = df_optimal_salary_war
  )
  
  ggplot(data = plotting_data) +
    geom_smooth(aes(x = total_salary, y = total_war), color = line_color, se = FALSE) +
    geom_point(aes(x = total_salary, y = total_war)) +
    theme_minimal() +
    scale_x_continuous(label = scales::dollar) + #, breaks = seq(0, 300E6, 50E6)) +
    labs(
      x = "Team Total Dollars Spent",
      y = "Team Total JEFFBAGWELL"
    ) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(face = "bold", size = 10)
    )
}

p_actual_war_salary <- Plot_WAR_VS_SALARY("actual")
p_optimal_war_salary <- Plot_WAR_VS_SALARY("optimal")

p_war_salary_cowplot <- plot_grid(p_actual_war_salary, p_optimal_war_salary, 
          labels = c("Actual Team Values", "Optimal Team Values"))

# Save Plots --------------------------------------------------------------

path_plots <- "paper/figures/"

ggsave(paste0(path_plots, "salary_hist.png"), p_salary_hist)
ggsave(paste0(path_plots, "war_hist.png"), p_war)
ggsave(paste0(path_plots, "salary_position_boxplots.png"), p_salary_position)
ggsave(paste0(path_plots, "war_position_boxplots.png"), p_war_position)
ggsave(paste0(path_plots, "bwar_salary_scatter_cowplot.png"), p_war_salary_cowplot, 
       width = 3500, height = 1500, units = "px")

# Tables ------------------------------------------------------------------

path_tables <- "paper/tables/"

df_lp %>% 
  count(player_name, sort = TRUE) %>% 
  rename(
    "Player" = player_name,
    "Teams Picked" = n
  ) %>% 
  kable(., format = "latex", caption = "Number of teams (max of 30) selecting a given player for their optimal roster", 
        escape = TRUE, align = c("cc")) %>% 
  kable_styling(., latex_options = "striped", font_size = 7) %>% 
  column_spec(., 1, border_left = TRUE) %>% 
  column_spec(., 2, border_right = TRUE) %>% 
  save_kable(., paste0(path_tables, "teams_picked.tex"))

v_teams <- df_players %>% 
  pull(team) %>% 
  unique()

df_optimal_equal_actual <- df_lp %>% 
  filter(optimal_team == actual_team) %>% 
  count(optimal_team, sort = TRUE)

v_teams_with_0 <- setdiff(v_teams, df_optimal_equal_actual$optimal_team)

df_optimal_equal_actual <- df_optimal_equal_actual %>% 
  add_row(
    optimal_team = v_teams_with_0,
    n = 0
  ) %>% 
  rename(
    Team = optimal_team,
    "Number of Players" = n
  )
        
kable(df_optimal_equal_actual, format = "latex", align = c("lc"),
      caption = "For each team, the number of players selected for their optimal team who are also on their actual team") %>% 
  kable_styling(., latex_options = "striped") %>% 
  column_spec(., 1, border_left = TRUE) %>% 
  column_spec(., 2, width = "10em", border_right = TRUE) %>% 
  save_kable(., paste0(path_tables, "num_players_actual_and_optimal.tex"))        
  
Save_Optimal_Roster <- function(team) {
  
  df_lp %>% 
    filter(optimal_team == team) %>% 
    select(
      `Actual Team` = actual_team,
      Player = player_name,
      Position = position, 
      JEFFBAGWELL = war_value,
      Salary = salary
    ) %>% 
    kable(., format = "latex", caption = paste("Optimal team for", team), escape = TRUE) %>% 
    kable_styling(., bootstrap_options = "striped") %>% 
    save_kable(., paste0(path_tables, team, "_optimal_team.tex"))  
}

walk(v_teams, ~ Save_Optimal_Roster(.))

\end{verbatim}


\end{singlespace}

\end{document}